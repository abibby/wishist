/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Wishist API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "/api".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name = "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface FriendBody
 */
export interface FriendBody {
    /**
     * 
     * @type {number}
     * @memberof FriendBody
     */
    friendId?: number;
}
/**
 * 
 * @export
 * @interface FriendBody1
 */
export interface FriendBody1 {
    /**
     * 
     * @type {number}
     * @memberof FriendBody1
     */
    friendId?: number;
}
/**
 * 
 * @export
 * @interface InlineResponseDefault
 */
export interface InlineResponseDefault {
    /**
     * 
     * @type {number}
     * @memberof InlineResponseDefault
     */
    friendId?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponseDefault
     */
    friendName?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponseDefault
     */
    friendUsername?: string;
}
/**
 * 
 * @export
 * @interface InlineResponseDefault1
 */
export interface InlineResponseDefault1 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponseDefault1
     */
    success?: boolean;
}
/**
 * 
 * @export
 * @interface InlineResponseDefault2
 */
export interface InlineResponseDefault2 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponseDefault2
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponseDefault2
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponseDefault2
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponseDefault2
     */
    purchasedCount?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponseDefault2
     */
    thinkingCount?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponseDefault2
     */
    url?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponseDefault2
     */
    userId?: number;
}
/**
 * 
 * @export
 * @interface InlineResponseDefault3
 */
export interface InlineResponseDefault3 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponseDefault3
     */
    expiresIn?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponseDefault3
     */
    refresh?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponseDefault3
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponseDefault3
     */
    tokenType?: string;
}
/**
 * 
 * @export
 * @interface InlineResponseDefault4
 */
export interface InlineResponseDefault4 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponseDefault4
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponseDefault4
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponseDefault4
     */
    username?: string;
}
/**
 * 
 * @export
 * @interface InlineResponseDefault5
 */
export interface InlineResponseDefault5 {
    /**
     * 
     * @type {InlineResponseDefault4}
     * @memberof InlineResponseDefault5
     */
    user?: InlineResponseDefault4;
}
/**
 * 
 * @export
 * @interface InlineResponseDefault6
 */
export interface InlineResponseDefault6 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponseDefault6
     */
    itemId?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponseDefault6
     */
    itemUserId?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponseDefault6
     */
    type?: string;
}
/**
 * 
 * @export
 * @interface ItemBody
 */
export interface ItemBody {
    /**
     * 
     * @type {string}
     * @memberof ItemBody
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof ItemBody
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ItemBody
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemBody
     */
    url?: string;
}
/**
 * 
 * @export
 * @interface ItemBody1
 */
export interface ItemBody1 {
    /**
     * 
     * @type {string}
     * @memberof ItemBody1
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemBody1
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemBody1
     */
    url?: string;
}
/**
 * 
 * @export
 * @interface ItemBody2
 */
export interface ItemBody2 {
    /**
     * 
     * @type {number}
     * @memberof ItemBody2
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface LoginBody
 */
export interface LoginBody {
    /**
     * 
     * @type {string}
     * @memberof LoginBody
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginBody
     */
    username?: string;
}
/**
 * 
 * @export
 * @interface LoginRefreshBody
 */
export interface LoginRefreshBody {
    /**
     * 
     * @type {string}
     * @memberof LoginRefreshBody
     */
    refresh?: string;
}
/**
 * 
 * @export
 * @interface PasswordChangeBody
 */
export interface PasswordChangeBody {
    /**
     * 
     * @type {string}
     * @memberof PasswordChangeBody
     */
    newPassword?: string;
    /**
     * 
     * @type {string}
     * @memberof PasswordChangeBody
     */
    oldPassword?: string;
}
/**
 * 
 * @export
 * @interface PasswordForgotBody
 */
export interface PasswordForgotBody {
    /**
     * 
     * @type {string}
     * @memberof PasswordForgotBody
     */
    email?: string;
}
/**
 * 
 * @export
 * @interface PasswordResetBody
 */
export interface PasswordResetBody {
    /**
     * 
     * @type {string}
     * @memberof PasswordResetBody
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof PasswordResetBody
     */
    token?: string;
}
/**
 * 
 * @export
 * @interface UserBody
 */
export interface UserBody {
    /**
     * 
     * @type {string}
     * @memberof UserBody
     */
    password?: string;
}
/**
 * 
 * @export
 * @interface UseritemBody
 */
export interface UseritemBody {
    /**
     * 
     * @type {number}
     * @memberof UseritemBody
     */
    itemId?: number;
    /**
     * 
     * @type {string}
     * @memberof UseritemBody
     */
    type?: string;
}
/**
 * 
 * @export
 * @interface UseritemBody1
 */
export interface UseritemBody1 {
    /**
     * 
     * @type {number}
     * @memberof UseritemBody1
     */
    itemId?: number;
    /**
     * 
     * @type {string}
     * @memberof UseritemBody1
     */
    type?: string;
}
/**
 * 
 * @export
 * @interface UseritemBody2
 */
export interface UseritemBody2 {
    /**
     * 
     * @type {number}
     * @memberof UseritemBody2
     */
    itemId?: number;
}
/**
 * AuthApi - fetch parameter creator
 * @export
 */
export const AuthApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [token] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authEmailVerify(token?: string, options: any = {}): FetchArgs {
            const localVarPath = `/user/verify`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LoginBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogin(body?: LoginBody, options: any = {}): FetchArgs {
            const localVarPath = `/login`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = '*/*';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LoginBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PasswordChangeBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authPasswordChange(body?: PasswordChangeBody, options: any = {}): FetchArgs {
            const localVarPath = `/user/password/change`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = '*/*';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PasswordChangeBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PasswordForgotBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authPasswordForgot(body?: PasswordForgotBody, options: any = {}): FetchArgs {
            const localVarPath = `/user/password/forgot`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = '*/*';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PasswordForgotBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PasswordResetBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authPasswordReset(body?: PasswordResetBody, options: any = {}): FetchArgs {
            const localVarPath = `/user/password/reset`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = '*/*';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PasswordResetBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LoginRefreshBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRefresh(body?: LoginRefreshBody, options: any = {}): FetchArgs {
            const localVarPath = `/login/refresh`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = '*/*';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LoginRefreshBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUserCreate(body?: UserBody, options: any = {}): FetchArgs {
            const localVarPath = `/user`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = '*/*';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [token] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authEmailVerify(token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AuthApiFetchParamCreator(configuration).authEmailVerify(token, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {LoginBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogin(body?: LoginBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponseDefault3> {
            const localVarFetchArgs = AuthApiFetchParamCreator(configuration).authLogin(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {PasswordChangeBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authPasswordChange(body?: PasswordChangeBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponseDefault5> {
            const localVarFetchArgs = AuthApiFetchParamCreator(configuration).authPasswordChange(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {PasswordForgotBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authPasswordForgot(body?: PasswordForgotBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = AuthApiFetchParamCreator(configuration).authPasswordForgot(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {PasswordResetBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authPasswordReset(body?: PasswordResetBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponseDefault5> {
            const localVarFetchArgs = AuthApiFetchParamCreator(configuration).authPasswordReset(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {LoginRefreshBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRefresh(body?: LoginRefreshBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponseDefault3> {
            const localVarFetchArgs = AuthApiFetchParamCreator(configuration).authRefresh(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {UserBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUserCreate(body?: UserBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponseDefault5> {
            const localVarFetchArgs = AuthApiFetchParamCreator(configuration).authUserCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} [token] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authEmailVerify(token?: string, options?: any) {
            return AuthApiFp(configuration).authEmailVerify(token, options)(fetch, basePath);
        },
        /**
         * 
         * @param {LoginBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogin(body?: LoginBody, options?: any) {
            return AuthApiFp(configuration).authLogin(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {PasswordChangeBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authPasswordChange(body?: PasswordChangeBody, options?: any) {
            return AuthApiFp(configuration).authPasswordChange(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {PasswordForgotBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authPasswordForgot(body?: PasswordForgotBody, options?: any) {
            return AuthApiFp(configuration).authPasswordForgot(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {PasswordResetBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authPasswordReset(body?: PasswordResetBody, options?: any) {
            return AuthApiFp(configuration).authPasswordReset(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {LoginRefreshBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRefresh(body?: LoginRefreshBody, options?: any) {
            return AuthApiFp(configuration).authRefresh(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {UserBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUserCreate(body?: UserBody, options?: any) {
            return AuthApiFp(configuration).authUserCreate(body, options)(fetch, basePath);
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @param {string} [token] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authEmailVerify(token?: string, options?: any) {
        return AuthApiFp(this.configuration).authEmailVerify(token, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {LoginBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authLogin(body?: LoginBody, options?: any) {
        return AuthApiFp(this.configuration).authLogin(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {PasswordChangeBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authPasswordChange(body?: PasswordChangeBody, options?: any) {
        return AuthApiFp(this.configuration).authPasswordChange(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {PasswordForgotBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authPasswordForgot(body?: PasswordForgotBody, options?: any) {
        return AuthApiFp(this.configuration).authPasswordForgot(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {PasswordResetBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authPasswordReset(body?: PasswordResetBody, options?: any) {
        return AuthApiFp(this.configuration).authPasswordReset(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {LoginRefreshBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authRefresh(body?: LoginRefreshBody, options?: any) {
        return AuthApiFp(this.configuration).authRefresh(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {UserBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authUserCreate(body?: UserBody, options?: any) {
        return AuthApiFp(this.configuration).authUserCreate(body, options)(this.fetch, this.basePath);
    }

}
/**
 * DefaultApi - fetch parameter creator
 * @export
 */
export const DefaultApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {FriendBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        friendCreate(body?: FriendBody, options: any = {}): FetchArgs {
            const localVarPath = `/friend`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = '*/*';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"FriendBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {FriendBody1} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        friendDelete(body?: FriendBody1, options: any = {}): FetchArgs {
            const localVarPath = `/friend`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = '*/*';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"FriendBody1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        friendList(options: any = {}): FetchArgs {
            const localVarPath = `/friend`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ItemBody1} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemCreate(body?: ItemBody1, options: any = {}): FetchArgs {
            const localVarPath = `/item`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = '*/*';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ItemBody1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ItemBody2} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemDelete(body?: ItemBody2, options: any = {}): FetchArgs {
            const localVarPath = `/item`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = '*/*';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ItemBody2" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [userId] 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemList(userId?: number, id?: number, options: any = {}): FetchArgs {
            const localVarPath = `/item`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ItemBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemUpdate(body?: ItemBody, options: any = {}): FetchArgs {
            const localVarPath = `/item`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = '*/*';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ItemBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrent(options: any = {}): FetchArgs {
            const localVarPath = `/user/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UseritemBody1} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userItemCreate(body?: UseritemBody1, options: any = {}): FetchArgs {
            const localVarPath = `/user-item`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = '*/*';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UseritemBody1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UseritemBody2} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userItemDelete(body?: UseritemBody2, options: any = {}): FetchArgs {
            const localVarPath = `/user-item`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = '*/*';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UseritemBody2" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [itemUserId] 
         * @param {number} [itemId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userItemList(itemUserId?: number, itemId?: number, options: any = {}): FetchArgs {
            const localVarPath = `/user-item`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (itemUserId !== undefined) {
                localVarQueryParameter['item_user_id'] = itemUserId;
            }

            if (itemId !== undefined) {
                localVarQueryParameter['item_id'] = itemId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UseritemBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userItemUpdate(body?: UseritemBody, options: any = {}): FetchArgs {
            const localVarPath = `/user-item`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = '*/*';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UseritemBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userList(username?: string, options: any = {}): FetchArgs {
            const localVarPath = `/user`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {FriendBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        friendCreate(body?: FriendBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponseDefault> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).friendCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {FriendBody1} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        friendDelete(body?: FriendBody1, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponseDefault1> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).friendDelete(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        friendList(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponseDefault>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).friendList(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ItemBody1} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemCreate(body?: ItemBody1, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponseDefault2> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).itemCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ItemBody2} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemDelete(body?: ItemBody2, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponseDefault1> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).itemDelete(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [userId] 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemList(userId?: number, id?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponseDefault2>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).itemList(userId, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ItemBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemUpdate(body?: ItemBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponseDefault2> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).itemUpdate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrent(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponseDefault4> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userCurrent(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {UseritemBody1} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userItemCreate(body?: UseritemBody1, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponseDefault6> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userItemCreate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {UseritemBody2} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userItemDelete(body?: UseritemBody2, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponseDefault1> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userItemDelete(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [itemUserId] 
         * @param {number} [itemId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userItemList(itemUserId?: number, itemId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponseDefault6>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userItemList(itemUserId, itemId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {UseritemBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userItemUpdate(body?: UseritemBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponseDefault6> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userItemUpdate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userList(username?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponseDefault4>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userList(username, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {FriendBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        friendCreate(body?: FriendBody, options?: any) {
            return DefaultApiFp(configuration).friendCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {FriendBody1} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        friendDelete(body?: FriendBody1, options?: any) {
            return DefaultApiFp(configuration).friendDelete(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        friendList(options?: any) {
            return DefaultApiFp(configuration).friendList(options)(fetch, basePath);
        },
        /**
         * 
         * @param {ItemBody1} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemCreate(body?: ItemBody1, options?: any) {
            return DefaultApiFp(configuration).itemCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ItemBody2} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemDelete(body?: ItemBody2, options?: any) {
            return DefaultApiFp(configuration).itemDelete(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [userId] 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemList(userId?: number, id?: number, options?: any) {
            return DefaultApiFp(configuration).itemList(userId, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ItemBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemUpdate(body?: ItemBody, options?: any) {
            return DefaultApiFp(configuration).itemUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrent(options?: any) {
            return DefaultApiFp(configuration).userCurrent(options)(fetch, basePath);
        },
        /**
         * 
         * @param {UseritemBody1} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userItemCreate(body?: UseritemBody1, options?: any) {
            return DefaultApiFp(configuration).userItemCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {UseritemBody2} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userItemDelete(body?: UseritemBody2, options?: any) {
            return DefaultApiFp(configuration).userItemDelete(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [itemUserId] 
         * @param {number} [itemId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userItemList(itemUserId?: number, itemId?: number, options?: any) {
            return DefaultApiFp(configuration).userItemList(itemUserId, itemId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {UseritemBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userItemUpdate(body?: UseritemBody, options?: any) {
            return DefaultApiFp(configuration).userItemUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userList(username?: string, options?: any) {
            return DefaultApiFp(configuration).userList(username, options)(fetch, basePath);
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @param {FriendBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public friendCreate(body?: FriendBody, options?: any) {
        return DefaultApiFp(this.configuration).friendCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {FriendBody1} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public friendDelete(body?: FriendBody1, options?: any) {
        return DefaultApiFp(this.configuration).friendDelete(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public friendList(options?: any) {
        return DefaultApiFp(this.configuration).friendList(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ItemBody1} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public itemCreate(body?: ItemBody1, options?: any) {
        return DefaultApiFp(this.configuration).itemCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ItemBody2} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public itemDelete(body?: ItemBody2, options?: any) {
        return DefaultApiFp(this.configuration).itemDelete(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [userId] 
     * @param {number} [id] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public itemList(userId?: number, id?: number, options?: any) {
        return DefaultApiFp(this.configuration).itemList(userId, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ItemBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public itemUpdate(body?: ItemBody, options?: any) {
        return DefaultApiFp(this.configuration).itemUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userCurrent(options?: any) {
        return DefaultApiFp(this.configuration).userCurrent(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {UseritemBody1} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userItemCreate(body?: UseritemBody1, options?: any) {
        return DefaultApiFp(this.configuration).userItemCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {UseritemBody2} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userItemDelete(body?: UseritemBody2, options?: any) {
        return DefaultApiFp(this.configuration).userItemDelete(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [itemUserId] 
     * @param {number} [itemId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userItemList(itemUserId?: number, itemId?: number, options?: any) {
        return DefaultApiFp(this.configuration).userItemList(itemUserId, itemId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {UseritemBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userItemUpdate(body?: UseritemBody, options?: any) {
        return DefaultApiFp(this.configuration).userItemUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [username] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userList(username?: string, options?: any) {
        return DefaultApiFp(this.configuration).userList(username, options)(this.fetch, this.basePath);
    }

}
